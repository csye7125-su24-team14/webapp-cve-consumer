package models

import (
	"encoding/json"
	"fmt"
	"log"

	"github.com/jackc/pgtype"
	"gorm.io/gorm"
)

type CVE struct {
	ID            pgtype.UUID  `gorm:"column:id;type:uuid;primary_key"`
	CveId         string       `gorm:"column:cveid;type:varchar(255);not null"`
	DateUpdated   string       `gorm:"column:dateupdated;not null"`
	DatePublished string       `gorm:"column:datepublished;not null"`
	CveMetadata   pgtype.JSONB `gorm:"column:cvemetadata;type:jsonb"`
	Containers    pgtype.JSONB `gorm:"column:containers;type:jsonb"`
	DataType      string       `gorm:"column:datatype;type:varchar(255)"`
	DataVersion   string       `gorm:"column:dataversion;type:varchar(255)"`
}

func (CVE) TableName() string {
	return "cve.cve"
}

type CveData struct {
	Containers  pgtype.JSONB `json:"containers"`
	CveMetadata CveMetadata  `json:"cveMetadata"`
	DataType    string       `json:"dataType"`
	DataVersion string       `json:"dataVersion"`
}

type CveMetadata struct {
	AssignerOrgId     string `json:"assignerOrgId"`
	AssignerShortName string `json:"assignerShortName"`
	CveId             string `json:"cveId"`
	DatePublished     string `json:"datePublished"`
	DateReserved      string `json:"dateReserved"`
	DateUpdated       string `json:"dateUpdated"`
	State             string `json:"state"`
}

func (c *CVE) SaveCve(byteValue []byte, db *gorm.DB) error {

	var cveData CveData
	if err := json.Unmarshal(byteValue, &cveData); err != nil {
		return fmt.Errorf("failed to unmarshal JSON data: %v", err)
	}

	var existingCVE *CVE
	if err := db.Where("cveid = ?", cveData.CveMetadata.CveId).First(&existingCVE).Error; err != nil {
		cveMetadata := pgtype.JSONB{}
		if err := cveMetadata.Set(cveData.CveMetadata); err != nil {
			return fmt.Errorf("failed to set cveMetadata: %v", err)
		}

		containers := pgtype.JSONB{}
		if err := containers.Set(cveData.Containers); err != nil {
			return fmt.Errorf("failed to set containers: %v", err)
		}
		dateUpdated := cveData.CveMetadata.DateUpdated
		if dateUpdated == "" {
			dateUpdated = cveData.CveMetadata.DatePublished
		}

		newCve := CVE{
			CveId:         cveData.CveMetadata.CveId,
			DateUpdated:   dateUpdated,
			DatePublished: cveData.CveMetadata.DatePublished,
			CveMetadata:   cveMetadata,
			Containers:    containers,
			DataType:      cveData.DataType,
			DataVersion:   cveData.DataVersion,
		}
		if err := db.Omit("ID").Create(&newCve).Error; err != nil { // Omit ID field
			// return err
			return fmt.Errorf("failed to create new CVE: %v", err)
		}
		fmt.Println("Inserted CVE:", newCve.CveId)

	} else {
		if existingCVE.DateUpdated != cveData.CveMetadata.DateUpdated && cveData.CveMetadata.DatePublished != cveData.CveMetadata.DateUpdated {
			cveMetadata := pgtype.JSONB{}
			if err := cveMetadata.Set(cveData.CveMetadata); err != nil {
				return fmt.Errorf("failed to set cveMetadata: %v", err)
			}

			containers := pgtype.JSONB{}
			if err := containers.Set(cveData.Containers); err != nil {
				return fmt.Errorf("failed to set containers: %v", err)
			}

			existingCVE.CveMetadata = cveMetadata
			existingCVE.Containers = containers
			existingCVE.DateUpdated = cveData.CveMetadata.DateUpdated
			existingCVE.DataType = cveData.DataType
			existingCVE.DataVersion = cveData.DataVersion
			existingCVE.DatePublished = cveData.CveMetadata.DatePublished
			if err := db.Model(&existingCVE).Where("cveid = ?", cveData.CveMetadata.CveId).Updates(existingCVE).Error; err != nil {
				log.Println("Error updating CVE:", err)
			} else {
				fmt.Println("Updated CVE:", existingCVE.CveId)
			}
		} else {
			fmt.Println("CVE already exists, skipping:", cveData.CveMetadata.CveId)
		}
	}

	return nil

	// fmt.Println("Finished processing all files")
}
