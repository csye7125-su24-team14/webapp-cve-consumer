package models

import (
	"encoding/json"
	"fmt"
	"log"

	"github.com/jackc/pgtype"
	"gorm.io/gorm"
)

type CVE struct {
	ID          pgtype.UUID  `gorm:"column:id;type:uuid;primary_key"`
	CveId       string       `gorm:"column:cveid;type:varchar(255);not null"`
	DateUpdated string       `gorm:"column:dateupdated;not null"`
	CveMetadata pgtype.JSONB `gorm:"column:cvemetadata;type:jsonb"`
	Containers  pgtype.JSONB `gorm:"column:containers;type:jsonb"`
	DataType    string       `gorm:"column:datatype;type:varchar(255)"`
	DataVersion string       `gorm:"column:dataversion;type:varchar(255)"`
}

func (CVE) TableName() string {
	return "cve.cve"
}

type CveData struct {
	Containers  pgtype.JSONB `json:"containers"`
	CveMetadata CveMetadata  `json:"cveMetadata"`
	DataType    string       `json:"dataType"`
	DataVersion string       `json:"dataVersion"`
}

type CveMetadata struct {
	AssignerOrgId     string `json:"assignerOrgId"`
	AssignerShortName string `json:"assignerShortName"`
	CveId             string `json:"cveId"`
	DatePublished     string `json:"datePublished"`
	DateReserved      string `json:"dateReserved"`
	DateUpdated       string `json:"dateUpdated"`
	State             string `json:"state"`
}

func (c *CVE) SaveCve(byteValue []byte, db *gorm.DB) {

	var cveData CveData
	if err := json.Unmarshal(byteValue, &cveData); err != nil {
		log.Fatalf("Failed to unmarshal JSON data: %v", err)
	}

	var existingCVE CVE
	if err := db.Where("cveid = ?", cveData.CveMetadata.CveId).First(&existingCVE).Error; err != nil {
		cveMetadata := pgtype.JSONB{}
		if err := cveMetadata.Set(cveData.CveMetadata); err != nil {
			log.Fatalf("Failed to set cveMetadata: %v", err)
		}

		containers := pgtype.JSONB{}
		if err := containers.Set(cveData.Containers); err != nil {
			log.Fatalf("Failed to set containers: %v", err)
		}
		dateUpdated := cveData.CveMetadata.DateUpdated
		if dateUpdated == "" {
			dateUpdated = cveData.CveMetadata.DatePublished
		}

		newCve := CVE{
			CveId:       cveData.CveMetadata.CveId,
			DateUpdated: dateUpdated,
			CveMetadata: cveMetadata,
			Containers:  containers,
			DataType:    cveData.DataType,
			DataVersion: cveData.DataVersion,
		}
		if err := db.Omit("ID").Create(&newCve).Error; err != nil { // Omit ID field
			// return err
			log.Println(err)
		}
		fmt.Println("Inserted CVE:", newCve.CveId)

	} else {
		if cveData.CveMetadata.DatePublished != cveData.CveMetadata.DateUpdated {
			cveMetadata := pgtype.JSONB{}
			if err := cveMetadata.Set(cveData.CveMetadata); err != nil {
				log.Fatalf("Failed to set cveMetadata: %v", err)
			}

			containers := pgtype.JSONB{}
			if err := containers.Set(cveData.Containers); err != nil {
				log.Fatalf("Failed to set containers: %v", err)
			}
			dateUpdated := cveData.CveMetadata.DateUpdated
			if dateUpdated == "" {
				dateUpdated = cveData.CveMetadata.DatePublished
			}

			updatedCve := CVE{
				CveId:       cveData.CveMetadata.CveId,
				DateUpdated: dateUpdated,
				CveMetadata: cveMetadata,
				Containers:  containers,
				DataType:    cveData.DataType,
				DataVersion: cveData.DataVersion,
			}

			// Update the existing record in the database
			if err := db.Model(&CVE{}).Where("cve_id = ?", cveData.CveMetadata.CveId).Updates(updatedCve).Error; err != nil {
				log.Println(err)
			}

			fmt.Println("Updated CVE:", updatedCve.CveId)
		} else {
			fmt.Println("CVE already exists, skipping:", cveData.CveMetadata.CveId)
		}
	}

	// fmt.Println("Finished processing all files")
}
