package consumer

import "fmt"

// import (
// 	"context"
// 	"log"
// 	"os"
// 	"strings"
// 	"time"

// 	"github.com/csye7125-su24-team14/webapp-cve-consumer/app/models"
// 	"github.com/segmentio/kafka-go"
// 	"github.com/segmentio/kafka-go/sasl/scram"
// 	"gorm.io/gorm"
// )

// func GetKafkaReader(kafkaURL, topic, groupID string) *kafka.Reader {

// 	mechanism, err := scram.Mechanism(scram.SHA256, os.Getenv("USERNAME"), os.Getenv("PASSWORD"))
// 	if err != nil {
// 		panic(err)
// 	}

// 	dialer := &kafka.Dialer{
// 		Timeout:       10 * time.Second,
// 		DualStack:     true,
// 		SASLMechanism: mechanism,
// 	}
// 	brokers := strings.Split(kafkaURL, ",")
// 	return kafka.NewReader(kafka.ReaderConfig{
// 		Brokers:  brokers,
// 		GroupID:  groupID,
// 		Topic:    topic,
// 		MinBytes: 10e3, // 10KB
// 		MaxBytes: 10e6, // 10MB
// 		MaxWait:  1 * time.Second,
// 		Dialer:   dialer,
// 	})
// }

// func ConsumeCves(db *gorm.DB) {
// 	kafkaURL := os.Getenv("kafkaURL")
// 	topic := os.Getenv("TOPIC_NAME")
// 	groupID := os.Getenv("groupID")

// 	reader := GetKafkaReader(kafkaURL, topic, groupID)
// 	defer func() {
// 		if err := reader.Close(); err != nil {
// 			log.Printf("failed to close reader: %v", err)
// 		}
// 	}()

// 	log.Println("Starting to consume messages...")
// 	cve := models.CVE{}
// 	for {
// 		m, err := reader.ReadMessage(context.Background())
// 		if err != nil {
// 			log.Printf("error while reading message: %v", err)
// 			continue
// 		}

// 		log.Printf("Message received - Topic: %v, Partition: %v, Offset: %v, Key: %s",
// 			m.Topic, m.Partition, m.Offset, string(m.Key))

// 		cve.SaveCve(m.Value, db)
// 	}
// }
func test() {
	fmt.Println("test")
}
