package consumer

import (
	"context"
	"os"
	"strings"
	"time"

	"github.com/IBM/sarama"
	"github.com/csye7125-su24-team14/webapp-cve-consumer/app/models"
	zlog "github.com/rs/zerolog/log"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/trace"
	"gorm.io/gorm"
)

func StartKafkaConsumer(db *gorm.DB) {
	config := sarama.NewConfig()
	config.ChannelBufferSize = 500
	config.Consumer.Fetch.Min = 10e3
	config.Consumer.Fetch.Default = 10e6
	config.Consumer.MaxWaitTime = 1 * time.Second
	config.Net.SASL.Enable = true
	config.Net.SASL.Mechanism = sarama.SASLTypeSCRAMSHA256
	config.Net.SASL.User = os.Getenv("USERNAME")
	config.Net.SASL.Password = os.Getenv("PASSWORD")
	config.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient { return &XDGSCRAMClient{HashGeneratorFcn: SHA256} }

	kafkaURL := os.Getenv("kafkaURL")
	brokers := strings.Split(kafkaURL, ",")
	topic := os.Getenv("TOPIC_NAME")
	groupID := os.Getenv("groupID")

	// config.Version = sarama.v2 // Set the appropriate Kafka version
	// config.Consumer.Return.Errors = true
	// config.Consumer.Offsets.Initial = sarama.OffsetOldest
	// Increase buffer size
	// config.ChannelBufferSize = 500
	// SASL configuration
	// config.Net.SASL.Handshake = true default
	// config.ClientID = "sasl_scram_client"
	// config.Metadata.Full = true

	config.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient { return &XDGSCRAMClient{HashGeneratorFcn: SHA256} }

	consumerGroup, err := sarama.NewConsumerGroup(brokers, groupID, config)
	if err != nil {

		zlog.Fatal().Err(err).Msg("Error creating consumer group")
	}
	defer consumerGroup.Close()

	consumerGroupHandler := &ConsumerGroupHandler{db: db}

	for {
		err := consumerGroup.Consume(context.Background(), []string{topic}, consumerGroupHandler)
		if err != nil {
			zlog.Error().Err(err).Msg("Error consuming messages")
		}
	}

}

type ConsumerGroupHandler struct {
	db *gorm.DB
}

func (h *ConsumerGroupHandler) Setup(_ sarama.ConsumerGroupSession) error {
	return nil
}

func (h *ConsumerGroupHandler) Cleanup(_ sarama.ConsumerGroupSession) error {
	return nil
}

func (h *ConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	cve := models.CVE{}
	tracer := otel.Tracer("consumer-group-handler")
	propagator := otel.GetTextMapPropagator()
	for {
		select {
		case message, ok := <-claim.Messages():
			if !ok {
				zlog.Info().Msg("message channel was closed")
				return nil
			}
			zlog.Info().Msgf("Received message with %d headers", len(message.Headers))
			for _, header := range message.Headers {
				zlog.Info().Msgf("Message Header - Key: %s, Value: %s",
					string(header.Key), string(header.Value))
			}
			zlog.Info().Msgf("Message received - Topic: %v, Partition: %v, Offset: %v, Key: %s", message.Topic, message.Partition, message.Offset, string(message.Key))

			ctx := propagator.Extract(context.Background(), NewMessageCarrier(message))
			_, span := tracer.Start(ctx, "process_cve",
				trace.WithAttributes(
					attribute.String("cveId", string(message.Key)),
					attribute.String("topic", message.Topic),
					attribute.Int64("offset", message.Offset),
				),
			)
			zlog.Info().
				Str("trace_id", span.SpanContext().TraceID().String()).
				Str("span_id", span.SpanContext().SpanID().String()).
				Msg("Consumed message")
			startTime := time.Now()
			err := cve.SaveCve(message.Value, h.db)
			duration := time.Since(startTime)

			if err != nil {
				zlog.Error().Err(err).Msgf("Error saving cve - Key: %s", string(message.Key))
			}

			// Add the processing duration as an attribute to the span
			span.SetAttributes(attribute.Int64("processing_time_ms", duration.Milliseconds()))

			// End the span
			span.End()
			session.MarkMessage(message, "")
		// Should return when `session.Context()` is done.
		// If not, will raise `ErrRebalanceInProgress` or `read tcp <ip>:<port>: i/o timeout` when kafka rebalance. see:
		// https://github.com/IBM/sarama/issues/1192
		case <-session.Context().Done():
			return nil
		}
	}
}

// MessageCarrier implements TextMapCarrier for sarama.ConsumerMessage
// serializing the headers into a format that can be used by OpenTelemetry
type MessageCarrier struct {
	msg *sarama.ConsumerMessage
}

func NewMessageCarrier(msg *sarama.ConsumerMessage) *MessageCarrier {
	return &MessageCarrier{msg: msg}
}

func (mc *MessageCarrier) Get(key string) string {
	for _, header := range mc.msg.Headers {
		if string(header.Key) == key {
			return string(header.Value)
		}
	}
	return ""
}

func (mc *MessageCarrier) Set(key string, value string) {
	mc.msg.Headers = append(mc.msg.Headers, &sarama.RecordHeader{
		Key:   []byte(key),
		Value: []byte(value),
	})
}

func (mc *MessageCarrier) Keys() []string {
	keys := make([]string, len(mc.msg.Headers))
	for i, header := range mc.msg.Headers {
		keys[i] = string(header.Key)
	}
	return keys
}
