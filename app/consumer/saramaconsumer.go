package consumer

import (
	"context"
	"log"
	"os"
	"strings"
	"time"

	"github.com/IBM/sarama"
	"github.com/csye7125-su24-team14/webapp-cve-consumer/app/models"
	"gorm.io/gorm"
)

func StartKafkaConsumer(db *gorm.DB) {
	config := sarama.NewConfig()
	config.ChannelBufferSize = 500
	config.Consumer.Fetch.Min = 10e3
	config.Consumer.Fetch.Default = 10e6
	config.Consumer.MaxWaitTime = 1 * time.Second
	config.Net.SASL.Enable = true
	config.Net.SASL.Mechanism = sarama.SASLTypeSCRAMSHA256
	config.Net.SASL.User = os.Getenv("USERNAME")
	config.Net.SASL.Password = os.Getenv("PASSWORD")
	config.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient { return &XDGSCRAMClient{HashGeneratorFcn: SHA256} }

	kafkaURL := os.Getenv("kafkaURL")
	brokers := strings.Split(kafkaURL, ",")
	topic := os.Getenv("TOPIC_NAME")
	groupID := os.Getenv("groupID")

	// config.Version = sarama.v2 // Set the appropriate Kafka version
	// config.Consumer.Return.Errors = true
	// config.Consumer.Offsets.Initial = sarama.OffsetOldest
	// Increase buffer size
	// config.ChannelBufferSize = 500
	// SASL configuration
	// config.Net.SASL.Handshake = true default
	// config.ClientID = "sasl_scram_client"
	// config.Metadata.Full = true

	config.Net.SASL.SCRAMClientGeneratorFunc = func() sarama.SCRAMClient { return &XDGSCRAMClient{HashGeneratorFcn: SHA256} }

	consumerGroup, err := sarama.NewConsumerGroup(brokers, groupID, config)
	if err != nil {
		log.Fatalf("Error creating consumer group: %v", err)
	}
	defer consumerGroup.Close()

	consumerGroupHandler := &ConsumerGroupHandler{db: db}

	for {
		err := consumerGroup.Consume(context.Background(), []string{topic}, consumerGroupHandler)
		if err != nil {
			log.Printf("Error consuming messages: %v", err)
		}
	}

}

type ConsumerGroupHandler struct {
	db *gorm.DB
}

func (h *ConsumerGroupHandler) Setup(_ sarama.ConsumerGroupSession) error {
	return nil
}

func (h *ConsumerGroupHandler) Cleanup(_ sarama.ConsumerGroupSession) error {
	return nil
}

func (h *ConsumerGroupHandler) ConsumeClaim(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {
	cve := models.CVE{}
	for {
		select {
		case message, ok := <-claim.Messages():
			if !ok {
				log.Printf("message channel was closed")
				return nil
			}
			log.Printf("Message received - Topic: %v, Partition: %v, Offset: %v, Key: %s",
				message.Topic, message.Partition, message.Offset, string(message.Key))
			err := cve.SaveCve(message.Value, h.db)
			if err != nil {
				log.Printf("Error saving cve - Key: %s, Error: %v", string(message.Key), err)

			}
			session.MarkMessage(message, "")
		// Should return when `session.Context()` is done.
		// If not, will raise `ErrRebalanceInProgress` or `read tcp <ip>:<port>: i/o timeout` when kafka rebalance. see:
		// https://github.com/IBM/sarama/issues/1192
		case <-session.Context().Done():
			return nil
		}
	}
}
